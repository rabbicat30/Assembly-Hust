
NAME demo4-1
EXTRN F2T10:NEAR,F10T2:NEAR
PUBLIC GOOD,OUTBUF,AUTH
.386
INCLUDE IO.LIB
STACK SEGMENT PARA STACK 'STACK'
	   DB 200 DUP(0)
STACK ENDS 

CODE	SEGMENT USE16 PARA PUBLIC 'CODE'
		ASSUME  CS:CODE, SS:STACK, DS:DATA, ES:DATA
		
	COUNTTIME DB 18
	HOUR DB ?,?,':'
	MIN DB ?,?,':'
	SEC DB ?,?
	BUF_LEN=$-HOUR
	ISSTACK0 DW 0
	ISSTACKBAK DW 0
	OLD_INT DW ?,?
	CURSOR DW ?

NEW08H PROC FAR
	PUSHF
	CALL DWORD PTR CS:OLD_INT
	DEC CS:COUNTTIME
	JZ DISP2
	IRET
DISP2:
	MOV CS:COUNTTIME,18
	
	STI
	PUSHA
	
	PUSH DS
	PUSH ES
	MOV AX,CS;将DS,ES指向CS
	MOV DS,AX
	MOV ES,AX
	CALL GET_TIME;获取当前时间
	
	MOV BH,0;获取0号显示页面当前的光标位置
	MOV AH,3
	INT 10H
	MOV CURSOR,DX
	MOV BP,OFFSET HOUR
	MOV BH,0
	MOV DH,0
	MOV DL,79-BUF_LEN
	MOV BL,07H
	MOV CX,BUF_LEN
	MOV AL,0
	MOV AH,13H
	INT 10H
	MOV BH,0
	MOV DX,CURSOR
	MOV AH,2
	INT 10H
	
	POP ES
	POP DS
	MOV BX,WORD PTR DS:SECOND
	MOV AX,WORD PTR CS:SEC
	XCHG AH,AL
	CMP BX,AX;直接写sec和bx比较得到的是反的
	JNE EXITRET;不相等中断返回
	MOV BX,SS;获取当前堆栈段的段地址0AB0
	MOV STACK0,BX
	MOV BX,SEG DS:STACKBAK;获取STACKBACK的段首址0B3E
	MOV DS:STACKBAK0,BX

	CMP DS:WHICHSTACK,0
	JE CHOOSE_STACKBAK;切换到STACKBAK
	;CRLF
	;OUT1 '1'
	;CRLF
	MOV CX,300;否则切换到STACK

L13:
	MOV DS:WHICHSTACK,0;堆栈段由STACKBAK切换到STACK
	MOV AX,STACK
	MOV SS,AX;切换到STACK
	MOV BP,0;BP指向STACK最上面
	MOV DI,0
L12:	
	CMP CX,0
	JE EXITRET
	MOV AX,WORD PTR [DI]
	MOV WORD PTR [BP],AX
	ADD DI,2
	ADD BP,2
	DEC CX
	JMP L12

	
CHOOSE_STACKBAK:
	;CRLF
	;OUT1 '0'
	;CRLF
	MOV CX,300
	MOV BP,0
	MOV DI,0
L11:	;复制600个字节大小的堆栈空间
	CMP CX,0
	JE L8
	MOV BX,WORD PTR SS:[BP]
	MOV WORD PTR [DI],BX
	ADD BP,2
	ADD DI,2
	DEC CX
	JMP L11

L8:		;切换ss和sp
	MOV DS:WHICHSTACK,1
	MOV AX,DATA
	MOV SS,AX;切换SS
	JMP EXITRET
	
EXITRET:
	POPA
	IRET
	
NEW08H ENDP

GET_TIME PROC 
	MOV AL,4
	OUT 70H,AL
	JMP $+2
	IN AL,71H
	MOV AH,AL
	AND AL,0FH
	SHR AH,4
	ADD AX,3030H;获得当前小时的ASCII值
	XCHG AH,AL
	MOV WORD PTR HOUR,AX
	
	MOV AL,2
	OUT 70H,AL
	JMP $+2
	IN AL,71H
	MOV AH,AL
	AND AL,0FH
	SHR AH,4
	ADD AX,3030H;获得当前分的ASCII值
	XCHG AH,AL
	MOV WORD PTR MIN,AX
	
	MOV AL,0
	OUT 70H,AL
	JMP $+2
	IN AL,71H
	MOV AH,AL
	AND AL,0FH
	SHR AH,4
	ADD AX,3030H;获得当前秒的ASCII值
	XCHG AH,AL
	MOV WORD PTR SEC,AX
	RET
GET_TIME ENDP
	
	

;///////////////////////////////////////////////
;///////////////////////////////////////////////
START:
	MOV AX,DATA
	MOV DS,AX
	
MENU:
	WRITE YOURNAME
	
	CMP AUTH,0
	JE CUSTOMER
	WRITE2 IN_NAME;显示当前用户名
LP1:	
	WRITE BROWSE_GOOD
	
	CMP GOOD,0
	JE DISPLAYNOGOOD;无浏览商品
	WRITE2 IN_GOOD;把偏移地址送到BX
	
LP2:
	WRITE MENU_B;显示菜单选项
	
	WRITE INPUT;提示输入功能选项

	MOV AH,1;获取输入
	INT 21H	

	CMP AL,'1';输入的选择不在1-9之间
	JL ERR
	CMP AL,'9'
	JG ERR

	SUB AL,30H;得到数字
	MOV AH,0
	MOVZX EBX,AL
	DEC EBX
	JMP MENU_A[2*EBX]

CUSTOMER:
	CRLF
	JMP LP1
	
DISPLAYNOGOOD:
	CRLF
	JMP LP2 
ERR:
	WRITE INERR
	JMP MENU
	
NOTLOGIN:
	WRITE NOTLOG
	JMP MENU
	
INPUTNAME:
	CMP AUTH,0
	JNE LOGGED
	WRITE PUTNAME;提示输入用户的名字

	READ IN_NAME;输入用户名字
	
	LEA BX,IN_NAME	
L0:	CMP BYTE PTR [BX+2],0DH;和回车比较
	JE ERR	;是回车输出错误信息

	
	LEA SI,BNAME
	MOV DI,OFFSET IN_NAME +2
	MOV AL,BYTE PTR [SI]
	MOV CX,7
L1:	CMP CX,0
	JE NAMEEXIT
	MOV AL,BYTE PTR [SI];这句话必须放到循环体中
	CMP AL,BYTE PTR [DI]
	JNE ERR;不相等，重新输入
	INC SI
	INC DI
	DEC CX
	JMP L1

NAMEEXIT :
	MOV BYTE PTR [DI],'$';将结束符放入定义的名称中

INPUTPASSWORD:
	WRITE PUTPASSWORD;提示输入用户的密码

	READ IN_PWD;输入密码
	
	CLI	;计时反跟踪开始 
	MOV AH,2CH
	INT 21H
	PUSH DX	;保存获取的秒和百分秒
	
	MOV CL,IN_PWD+1;比较输入串和密码的长度是否一致
	XOR CL,'C'
	SUB CL,BPASS;得到输入字符串和设定字符串的长度的差值
	MOVSX BX,CL
	ADD BX,OFFSET P1
	
	MOV AH,2CH;获取第二次计时的秒和百分秒
	INT 21H
	STI
	CMP DX,[ESP];计时是否相同
	POP DX
	JZ OK1;相同通过本次计时反跟踪
	MOV BX,OFFSET E1;不相同，将退出程序

OK1:
	;CMP PASSCOUNT,0
	;JE EXIT
	MOV BX,[BX]
	CMP BX,P1;是否为PASS1处的指令，其实是用于判断前面比较的字长是否相等
	JZ OK2
	JMP ERR2

OK2:
	JMP BX
	DB 'HOW TO GO';定义冗余信息扰乱视线
	
PASS1:
	MOVZX CX,IN_PWD+1;获得输入密码的长度	
	CLI		;堆栈检查反跟踪
	PUSH P2		;PASS2的地址压栈
	POP AX
	MOV BX,[ESP-2]	;将栈顶上面的字（PASS2的地址）取到
	STI
	JMP BX			;如果被跟踪，不会到L2去
	DB 'I DO NOT KNOW!'
	
L2:	
	MOV SI,OFFSET BPASS+1
	MOV DI,OFFSET IN_PWD +2
	
L14:	
	CMP CX,0
	JE PWDEXIT
	MOV AL,BYTE PTR [DI]
	SUB AL,29H
	SHL AL,1;将输入的密码转化为密文比较
	CMP AL,BYTE PTR [SI]
	JNE ERR2;不相等，重新输入
	INC SI
	INC DI
	DEC CX
	JMP L14
	
ERR2:
	WRITE INERR
	;DEC PASSCOUNT
	JMP MENU
	DB 'YES,GET IT'

	
PWDEXIT:
	CMP BYTE PTR [SI],0
	JNE ERR2;还要比较定义的字符串的下一个字符是否为0避免子串的误判问题
	WRITE LOGIN;	登录成功提示
	MOV AUTH,1;输入成功
	JMP MENU;	登录成功后返回主菜单

FINDGOOD:
	WRITE GOODNAME;提醒输入商品名称

	READ IN_GOOD

	LEA SI,GA1
	LEA BX,GA1
	MOV DI,OFFSET IN_GOOD+2
	MOV CX,3
L3:	CMP CX,0
	JE ERR	;等于零，全部找完也没找到，提示失败
L4:	MOV AL,BYTE PTR [SI]
	CMP AL,0
	JE FINDSUS	;名称相符，查找成功，返回菜单
	XOR AL,'C'
	CMP AL,BYTE PTR [DI]
	JNE FINDFAITH	;名称不相符，查找下一个
	INC SI
	INC DI
	JMP L4
	 
FINDSUS:
	CMP BYTE PTR [DI],'0';字符0！
	JNE ERR;还要确定物品名称不是输入的字符串的子串
	MOV BYTE PTR [DI],'$'
	MOV GOOD,BX;将地址信息存放到good中,直接存放就可以
	WRITE FINDSUC
	CRLF
	WRITE2 IN_GOOD;显示指定商品的名称
	OUT1 ' '
	
	CALL F2T10
	CRLF
	WRITE OUTBUF
	JMP MENU

FINDFAITH:
	ADD BX,21;查找失败，偏移地址加21个字节,跳转到下一个商品
	MOV SI,BX
	MOV DI,OFFSET IN_GOOD+2
	DEC CX
	JMP L3
;推荐度=（进货价/实际销售价格+已售数量/（2*进货数量））*128
;进货价，销售价，进货总数，已售数目，推荐度，字类型
BUYGOOD:
	MOV AX,0
	CALL TIMER
	MOV BP,M;不能和N公用CX
	CMP GOOD,0
	JE NO_GOOD
	MOV  BX,GOOD
L7:
	MOV SI,[BX+15];获得进货总数,不能写成BX+15
	MOV DI,[BX+17];获得已售数目
	CMP SI,DI
	JZ NO_GOOD
	INC DI
	MOV [BX+17],DI
	JMP COUNT
L6:
	DEC BP
	CMP BP,0
	JE	LOOPOVER
	JMP L7
	
LOOPOVER:
    CRLF
	MOV AX,1
	CALL TIMER
	JMP MENU
COUNT:
	MOV BX,OFFSET GA1
	MOVZX EBX,BX
	MOV CX,N
L5:	CMP CX,0
	JE L6;全部计算完毕
	MOV EAX,[EBX+17];获得已售数目
	AND EAX,0FFFFH
	SHL EAX,6;先乘以64
	MOV EDX,0
	MOV EDI,[EBX+15];获得进货数量	
	AND EDI,0FFFFH;注意这里EDI应该和0FFFFH相与
	DIV EDI;再除以进货数量
	MOV C1,EAX;商->C1
	MOV EAX,[EBX+13];得到销售价
	AND EAX,0FFFFH
	MUL BYTE PTR [EBX+10];销售价乘以折扣
	MOV EDI,10
	MOV EDX,0;不要忘记将高位置0
	DIV EDI;再除以10得到实际销售价
	MOV EDI,EAX;得到的结果放入EDI中
	MOV EAX,[EBX+11];得到进价
	
	XOR EAX,'6';解密得到真正的进价
	
	AND EAX,0FFFFH
	MOV EDX,0
	SHL EAX,7;进货价乘以128
	DIV EDI;得到公式的前半部分(进价/实际销售价格）
	ADD EAX,C1
	MOV WORD PTR [EBX+19],AX
	ADD EBX,21
	DEC CX
	JMP L5
	
ARRAY:
	JMP MENU
;实验三第一个任务第二部分
;修改商品信息
CHANGEINFO:
	CALL F10T2
	CMP AUTH,0
	JE MENU
	CMP GOOD,0
	JE MENU
	CALL F2T10
	CRLF
	WRITE OUTBUF
	JMP MENU
CHANGEEN:
	CMP SET,1
	JE MENU
	PUSH CS
	POP DS
	MOV AX,3508H
	INT 21H
	
	MOV OLD_INT,BX;保存老的中断矢量
	MOV OLD_INT+2,ES
	MOV DX,OFFSET NEW08H
	MOV AX,2508H
	INT 21H
	;这里要修改set的值先要修改DS
	;MOV AX,DATA
	;MOV DS,AX
	;MOV SET,1
	JMP START
	
DISPLAY:
	CRLF
	MOV CX,4
	MOV BX,SS
LOOP1:
	ROL BX,4
	MOV AL,BL
	AND AL,0FH
	ADD AL,30H
	CMP AL,3AH
	JL DISP
	ADD AL,7
DISP:
	OUT1 AL
	DEC CX
	JNZ LOOP1
	JMP MENU
	
NO_GOOD:
	WRITE NOGOOD
	
	CRLF
	
	MOV AX,1
	CALL TIMER
	JMP MENU
	
LOGGED:
	WRITE HAVELOGINED
	JMP MENU

	
;子程序--计时	
TIMER	PROC
	PUSH  DX
	PUSH  CX
	PUSH  BX
	MOV   BX, AX
	MOV   AH, 2CH
	INT   21H	     ;CH=hour(0-23),CL=minute(0-59),DH=second(0-59),DL=centisecond(0-100)
	MOV   AL, DH
	MOV   AH, 0
	IMUL  AX,AX,1000
	MOV   DH, 0
	IMUL  DX,DX,10
	ADD   AX, DX
	CMP   BX, 0
	JNZ   _T1
	MOV   CS:_TS, AX
_T0:	POP   BX
	POP   CX
	POP   DX
	RET
_T1:	SUB   AX, CS:_TS
	JNC   _T2
	ADD   AX, 60000
_T2:	MOV   CX, 0
	MOV   BX, 10
_T3:	MOV   DX, 0
	DIV   BX
	PUSH  DX
	INC   CX
	CMP   AX, 0
	JNZ   _T3
	MOV   BX, 0
_T4:	POP   AX
	ADD   AL, '0'
	MOV   CS:_TMSG[BX], AL
	INC   BX
	LOOP  _T4
	PUSH  DS
	MOV   CS:_TMSG[BX+0], 0AH
	MOV   CS:_TMSG[BX+1], 0DH
	MOV   CS:_TMSG[BX+2], '$'
	LEA   DX, _TS+2
	PUSH  CS
	POP   DS
	MOV   AH, 9
	INT   21H
	POP   DS
	JMP   _T0
_TS	DW    ?
 	DB    'Time elapsed in ms is '
_TMSG	DB    12 DUP(0)
TIMER   ENDP


EXIT:
	CMP SET,1
	JNE NEXT
	LDS DX,DWORD PTR OLD_INT;恢复终端处理程序 的入口地址
	MOV AX,2508H
	INT 21H
NEXT:	
	MOV AH,4CH
	INT 21H

DATA	SEGMENT USE16 PARA PUBLIC 'DATA'
STACKBAK DB 600 DUP(0);定义一个和堆栈段同样大小的数据段
BNAME  DB	'LIU MEI',0  ;老板姓名
BPASS  DB 6 XOR 'C';密码长度为6 
	   DB	('3'-29H)*2,('5'-29H)*2,('8'-29H)*2,('6'-29H)*2,('6'-29H)*2,('6'-29H)*2,0
	   DB  0A1H,5FH,0D3H;用随机数填充密码区到到10个字符防止破解者猜到密码长度
	   ;密码,采用(X-29H)*3对保存的密码进行编码
AUTH  DB		0  ;当前登录状态
GOOD  DW 0
N  EQU	3  ;商品的数量
SNAME  DB	'LMSHOP',0  ;网店名称，用0结束
GA1  DB		'P'XOR 'C','E'XOR 'C','N'XOR 'C',7 DUP(0),10  ;商品名称及折扣
         DW  	35 XOR '6',56,70,25,?  ;推荐度还未计算
GA2  DB		'B'XOR 'C','O'XOR 'C','O'XOR 'C','K'XOR 'C', 6 DUP(0),9
         DW		12 XOR '6',30,25,5,?
GAN  DB		N-2 DUP('T'XOR 'C','e'XOR 'C','m'XOR 'C','p'XOR 'C','V'XOR 'C','a'XOR 'C','l'XOR 'C','u'XOR 'C','e'XOR 'C',0,8 XOR '6',15,0,20,0,30,0,2,0,?,?)
C1 DD 0;用来存放商
C2 DD 2
C3 DD 128
OUTBUF DB 45 DUP(0)
PUTNAME   DB		0AH,0DH,'Please Input Your Name: ','$'
PUTPASSWORD  DB	0AH,0DH,'Please Inout Your Password: ','$'
INPUT  DB	0AH,0DH,'Please Input X(1-9): ','$',0AH,0DH
INERR  DB	0AH,0DH,'Input Error!Try Aggain!','$'
LOGIN DB	0AH,0DH,'Login Successfully!','$'
GOODNAME  DB	0AH,0DH,'Input the Name of Goods You Look Up And End With 0: ','$'
NOTLOG  DB	0AH,0DH,'Please Log In First!','$'
NOGOOD DB	0AH,0DH,'No Good Left','$'
FINDSUC DB 0AH,0DH,'Find Successfully!$'
MENU_A DW INPUTNAME,FINDGOOD,BUYGOOD,COUNT,ARRAY,CHANGEINFO,CHANGEEN,DISPLAY,EXIT
MENU_B DB 0AH,0DH,'1.LOG IN',0AH,0DH,'2.FINDGOOD',0AH,0DH,'3.BUYGOOD',0AH,0DH,'4.COUNT POPULATION',0AH,0DH,'5.ARRAY',0AH,0DH,'6.CHANGEINFOMATION',0AH,0DH,'7.CHANGE ENVIRONMENT',0AH,0DH,'8.DISPLAY ADDRESS',0AH,0DH,'9.EXIT$'
YOURNAME DB 0AH,0DH,'NAME: $'
BROWSE_GOOD DB 0AH,0DH,'GOOD: $'
HAVELOGINED DB 'You Have Logged In$'
SECOND DW '20'
INPUT_TIME DB 0AH,0DH,'Please Input the Time You Want to Set: $' 
SET DW 0
STACK0 DW 0
WHICHSTACK DB 0;如果是0表示应该切换到stackbak，为1切换到STACK
STACKBAK0 DW 0
M  EQU 1
P1 DW PASS1	;地址表用于间接转移反跟踪
E1 DW EXIT
P2 DW L2
PASSCOUNT DB 3;设置输入密码的最大次数为3

IN_NAME  DB 8
	DB ?
	DB 8 DUP(0)
IN_PWD  DB 10;输入的密码最大长度为10
	DB ?
	DB 7 DUP(0)
IN_GOOD DB 11
	DB ?
	DB 11 DUP(0)

DATA	ENDS
CODE	ENDS
	END  START